###############################################################################
#                                                                             #
# IAR C/C++ Compiler V6.11.1.50453 for Atmel AVR        12/Jun/2019  15:16:35 #
# Copyright 1996-2011 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  C:\Users\troub\CloudStation\Public\3. DST\7. DH-OWC\3.   #
#                    FIRMWARE\2. MIDO-ALMDDS-JST_v1_4\1.                      #
#                    MIDO-ALMDDS-JST_v1_4_190606\Source\drivers\atmel_driver\ #
#                    avr_twi_master_driver.c                                  #
#    Command line =  "C:\Users\troub\CloudStation\Public\3. DST\7. DH-OWC\3.  #
#                    FIRMWARE\2. MIDO-ALMDDS-JST_v1_4\1.                      #
#                    MIDO-ALMDDS-JST_v1_4_190606\Source\drivers\atmel_driver\ #
#                    avr_twi_master_driver.c" --cpu=m168pa -ms -o             #
#                    "C:\Users\troub\CloudStation\Public\3. DST\7. DH-OWC\3.  #
#                    FIRMWARE\2. MIDO-ALMDDS-JST_v1_4\1.                      #
#                    MIDO-ALMDDS-JST_v1_4_190606\Debug\Obj\" -lC              #
#                    "C:\Users\troub\CloudStation\Public\3. DST\7. DH-OWC\3.  #
#                    FIRMWARE\2. MIDO-ALMDDS-JST_v1_4\1.                      #
#                    MIDO-ALMDDS-JST_v1_4_190606\Debug\List\" -lA             #
#                    "C:\Users\troub\CloudStation\Public\3. DST\7. DH-OWC\3.  #
#                    FIRMWARE\2. MIDO-ALMDDS-JST_v1_4\1.                      #
#                    MIDO-ALMDDS-JST_v1_4_190606\Debug\List\"                 #
#                    --initializers_in_flash --no_cse --no_inline             #
#                    --no_code_motion --no_cross_call --no_clustering         #
#                    --no_tbaa --debug -e -I "C:\Users\troub\CloudStation\Pub #
#                    lic\3. DST\7. DH-OWC\3. FIRMWARE\2.                      #
#                    MIDO-ALMDDS-JST_v1_4\1. MIDO-ALMDDS-JST_v1_4_190606\Sour #
#                    ce\drivers\min_driver\" -I "C:\Users\troub\CloudStation\ #
#                    Public\3. DST\7. DH-OWC\3. FIRMWARE\2.                   #
#                    MIDO-ALMDDS-JST_v1_4\1. MIDO-ALMDDS-JST_v1_4_190606\Sour #
#                    ce\drivers\atmel_driver\" -I                             #
#                    "C:\Users\troub\CloudStation\Public\3. DST\7. DH-OWC\3.  #
#                    FIRMWARE\2. MIDO-ALMDDS-JST_v1_4\1.                      #
#                    MIDO-ALMDDS-JST_v1_4_190606\Source\" -I                  #
#                    "C:\Users\troub\CloudStation\Public\3. DST\7. DH-OWC\3.  #
#                    FIRMWARE\2. MIDO-ALMDDS-JST_v1_4\1.                      #
#                    MIDO-ALMDDS-JST_v1_4_190606\" --eeprom_size 512 --dlib   #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.0\avr\LIB\DLIB\dlAVR-3s-ec_ #
#                    mul-sf-n.h" -Ol                                          #
#    List file    =  C:\Users\troub\CloudStation\Public\3. DST\7. DH-OWC\3.   #
#                    FIRMWARE\2. MIDO-ALMDDS-JST_v1_4\1.                      #
#                    MIDO-ALMDDS-JST_v1_4_190606\Debug\List\avr_twi_master_dr #
#                    iver.lst                                                 #
#    Object file  =  C:\Users\troub\CloudStation\Public\3. DST\7. DH-OWC\3.   #
#                    FIRMWARE\2. MIDO-ALMDDS-JST_v1_4\1.                      #
#                    MIDO-ALMDDS-JST_v1_4_190606\Debug\Obj\avr_twi_master_dri #
#                    ver.r90                                                  #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\troub\CloudStation\Public\3. DST\7. DH-OWC\3. FIRMWARE\2. MIDO-ALMDDS-JST_v1_4\1. MIDO-ALMDDS-JST_v1_4_190606\Source\drivers\atmel_driver\avr_twi_master_driver.c
      1          /*****************************************************************************
      2          * Atmel Corporation
      3          * File              : TWI_master.c
      4          * Revision          : 1.13
      5          * Date              : 24. mai 2004 11:31:20
      6          * Updated by        : ltwa
      7          * Support mail      : avr@atmel.com
      8          * Supported devices : All devices with a TWI module can be used.
      9          * AppNote           : AVR315 - TWI master Implementation
     10          * Description       : This is a sample driver for the TWI hardware modules.
     11          *                     It is interrupt driven. All functionality is controlled through
     12          *                     passing information to and from functions. 
     13          ****************************************************************************/
     14          //#include "TWI_master.h"
     15          //#include <stdint.h>
     16          //#include <avr/io.h>
     17          //#include <avr/interrupt.h>
     18          
     19          #include "include.h"

   \                                 In  segment ABSOLUTE, at 0xbc
   \   union <unnamed> volatile __io _A_TWCR
   \                     _A_TWCR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xbb
   \   union <unnamed> volatile __io _A_TWDR
   \                     _A_TWDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xb9
   \   union <unnamed> volatile __io _A_TWSR
   \                     _A_TWSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xb8
   \   union <unnamed> volatile __io _A_TWBR
   \                     _A_TWBR:
   \   00000000                      DS8 1
     20          

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     21          uint8_t TWI_buf[TWI_BUFFER_SIZE];     // Transceiver buffer
   \                     TWI_buf:
   \   00000000                      DS8 16

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     22          static uint8_t TWI_msgSize;                  // Number of bytes to be transmitted.
   \                     TWI_msgSize:
   \   00000000                      DS8 1

   \                                 In  segment NEAR_I, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_I>`
     23          static uint8_t TWI_state = TWI_NO_STATE;     // State byte. Default set to TWI_NO_STATE.
   \                     TWI_state:
   \   00000000                      DS8 1
   \   00000001                      REQUIRE `?<Initializer for TWI_state>`
     24          

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     25          union TWI_statusReg_f TWI_statusReg = {0};         // TWI_statusReg is defined in TWI_master.h
   \                     TWI_statusReg:
   \   00000000                      DS8 1
     26          
     27          /****************************************************************************
     28          Call this function to set up the TWI master to its initial standby state.
     29          Remember to enable interrupts from the main application after initializing the TWI.
     30          ****************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     31          void TWI_Master_Initialise(void)
   \                     TWI_Master_Initialise:
     32          {
     33             TWBR = TWI_TWBR;                                // Set bit rate register (Baudrate). Defined in header file.
   \   00000000   E200               LDI     R16, 32
   \   00000002   9300....           STS     _A_TWBR, R16
     34             TWSR = TWI_TWPS;                               // Set prescaler
   \   00000006   E000               LDI     R16, 0
   \   00000008   9300....           STS     _A_TWSR, R16
     35             TWDR = 0xFF;                                    // Default content = SDA released.
   \   0000000C   EF0F               LDI     R16, 255
   \   0000000E   9300....           STS     _A_TWDR, R16
     36             TWCR = (1<<TWEN)|                               // Enable TWI-interface and release TWI pins.
     37                    (0<<TWIE)|(0<<TWINT)|                    // Disable Interrupt.
     38                    (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|         // No Signal requests.
     39                    (0<<TWWC);
   \   00000012   E004               LDI     R16, 4
   \   00000014   9300....           STS     _A_TWCR, R16
     40          }
   \   00000018   9508               RET
   \   0000001A                      REQUIRE _A_TWBR
   \   0000001A                      REQUIRE _A_TWSR
   \   0000001A                      REQUIRE _A_TWDR
   \   0000001A                      REQUIRE _A_TWCR
     41          
     42          /****************************************************************************
     43          Call this function to test if the TWI_ISR is busy transmitting.
     44          ****************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     45          uint8_t TWI_Transceiver_Busy(void)
   \                     TWI_Transceiver_Busy:
     46          {
     47             return TWCR & (1<<TWIE);                     // IF TWI Interrupt is enabled then the Transceiver is busy
   \   00000000   9110....           LDS     R17, _A_TWCR
   \   00000004   2F01               MOV     R16, R17
   \   00000006   7001               ANDI    R16, 0x01
   \   00000008   9508               RET
   \   0000000A                      REQUIRE _A_TWCR
     48          }
     49          
     50          /****************************************************************************
     51          Call this function to fetch the state information of the previous operation. The function will hold execution (loop)
     52          until the TWI_ISR has completed with the previous operation. If there was an error, then the function
     53          will return the TWI State code.
     54          ****************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     55          uint8_t TWI_Get_State_Info(void)
   \                     TWI_Get_State_Info:
   \                     ??TWI_Get_State_Info_0:
     56          {
     57             while(TWI_Transceiver_Busy());               // Wait until TWI has completed the transmission.
   \   00000000   ....               RCALL   TWI_Transceiver_Busy
   \   00000002   2300               TST     R16
   \   00000004   F7E9               BRNE    ??TWI_Get_State_Info_0
     58             return TWI_state;                            // Return error state.
   \   00000006   9100....           LDS     R16, TWI_state
   \   0000000A   9508               RET
     59          }
     60          
     61          /****************************************************************************
     62          Call this function to send a prepared message. The first byte must contain the slave address and the
     63          read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
     64          from the slave. Also include how many bytes that should be sent/read including the address byte.
     65          The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
     66          then initialize the next operation and return.
     67          ****************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     68          void TWI_Start_Transceiver_With_Data(uint8_t *msg, uint8_t msgSize)
   \                     TWI_Start_Transceiver_With_Data:
     69          {
   \   00000000   ........           CALL    ?PROLOGUE4_L09
   \   00000004   01D8               MOVW    R27:R26, R17:R16
   \   00000006   2F82               MOV     R24, R18
     70             uint8_t temp;
     71             while(TWI_Transceiver_Busy());                // Wait until TWI is ready for next transmission.
   \                     ??TWI_Start_Transceiver_With_Data_0:
   \   00000008   ....               RCALL   TWI_Transceiver_Busy
   \   0000000A   2300               TST     R16
   \   0000000C   F7E9               BRNE    ??TWI_Start_Transceiver_With_Data_0
     72          
     73             TWI_msgSize = msgSize;                        // Number of data to transmit.
   \   0000000E   9380....           STS     TWI_msgSize, R24
     74             TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
   \   00000012   01FD               MOVW    R31:R30, R27:R26
   \   00000014   8100               LD      R16, Z
   \   00000016   9300....           STS     TWI_buf, R16
     75             if(!(msg[0] & (TRUE<<TWI_READ_BIT)))          // If it is a write operation, then also copy data.
   \   0000001A   910C               LD      R16, X
   \   0000001C   FD00               SBRC    R16, 0
   \   0000001E   C00F               RJMP    ??TWI_Start_Transceiver_With_Data_1
     76             {
     77                for(temp = 1; temp < msgSize; temp += 1)
   \   00000020   E001               LDI     R16, 1
   \   00000022   C00B               RJMP    ??TWI_Start_Transceiver_With_Data_2
     78                   TWI_buf[temp] = msg[temp];
   \                     ??TWI_Start_Transceiver_With_Data_3:
   \   00000024   E010               LDI     R17, 0
   \   00000026   01FD               MOVW    R31:R30, R27:R26
   \   00000028   0FE0               ADD     R30, R16
   \   0000002A   1FF1               ADC     R31, R17
   \   0000002C   8120               LD      R18, Z
   \   0000002E   E010               LDI     R17, 0
   \   00000030   01F8               MOVW    R31:R30, R17:R16
   \   00000032   ....               SUBI    R30, LOW((-(TWI_buf) & 0xFFFF))
   \   00000034   ....               SBCI    R31, (-(TWI_buf) & 0xFFFF) >> 8
   \   00000036   8320               ST      Z, R18
   \   00000038   9503               INC     R16
   \                     ??TWI_Start_Transceiver_With_Data_2:
   \   0000003A   1708               CP      R16, R24
   \   0000003C   F398               BRCS    ??TWI_Start_Transceiver_With_Data_3
     79             }
     80          
     81             TWI_statusReg.all = 0;
   \                     ??TWI_Start_Transceiver_With_Data_1:
   \   0000003E   E000               LDI     R16, 0
   \   00000040   9300....           STS     TWI_statusReg, R16
     82             TWI_state = TWI_NO_STATE;
   \   00000044   EF08               LDI     R16, 248
   \   00000046   9300....           STS     TWI_state, R16
     83             TWCR = (1<<TWEN)|                             // TWI Interface enabled.
     84                    (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interrupt and clear the flag.
     85                    (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
     86                    (0<<TWWC);
   \   0000004A   EA05               LDI     R16, 165
   \   0000004C   9300....           STS     _A_TWCR, R16
     87          }
   \   00000050   E0E4               LDI     R30, 4
   \   00000052   ........           JMP     ?EPILOGUE_B4_L09
   \   00000056                      REQUIRE _A_TWCR
     88          
     89          /****************************************************************************
     90          Call this function to resend the last message. The driver will reuse the data previously put in the transceiver buffers.
     91          The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
     92          then initialize the next operation and return.
     93          ****************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     94          void TWI_Start_Transceiver(void)
   \                     TWI_Start_Transceiver:
   \                     ??TWI_Start_Transceiver_0:
     95          {
     96             while(TWI_Transceiver_Busy());                // Wait until TWI is ready for next transmission.
   \   00000000   ....               RCALL   TWI_Transceiver_Busy
   \   00000002   2300               TST     R16
   \   00000004   F7E9               BRNE    ??TWI_Start_Transceiver_0
     97             TWI_statusReg.all = 0;
   \   00000006   E000               LDI     R16, 0
   \   00000008   9300....           STS     TWI_statusReg, R16
     98             TWI_state = TWI_NO_STATE;
   \   0000000C   EF08               LDI     R16, 248
   \   0000000E   9300....           STS     TWI_state, R16
     99             TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    100                    (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interrupt and clear the flag.
    101                    (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
    102                    (0<<TWWC);
   \   00000012   EA05               LDI     R16, 165
   \   00000014   9300....           STS     _A_TWCR, R16
    103          }
   \   00000018   9508               RET
   \   0000001A                      REQUIRE _A_TWCR
    104          
    105          /****************************************************************************
    106          Call this function to read out the requested data from the TWI transceiver buffer. I.e. first call
    107          TWI_Start_Transceiver to send a request for data to the slave. Then Run this function to collect the
    108          data when they have arrived. Include a pointer to where to place the data and the number of bytes
    109          requested (including the address field) in the function call. The function will hold execution (loop)
    110          until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
    111          If there was an error in the previous transmission the function will return the TWI error code.
    112          ****************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    113          uint8_t TWI_Get_Data_From_Transceiver(uint8_t *msg, uint8_t msgSize)
   \                     TWI_Get_Data_From_Transceiver:
    114          {
   \   00000000   ........           CALL    ?PROLOGUE3_L09
   \   00000004   01C8               MOVW    R25:R24, R17:R16
   \   00000006   2FA2               MOV     R26, R18
    115             uint8_t i;
    116             while(TWI_Transceiver_Busy());               // Wait until TWI is ready for next transmission.
   \                     ??TWI_Get_Data_From_Transceiver_0:
   \   00000008   ....               RCALL   TWI_Transceiver_Busy
   \   0000000A   2300               TST     R16
   \   0000000C   F7E9               BRNE    ??TWI_Get_Data_From_Transceiver_0
    117          
    118             if(TWI_statusReg.lastTransOK)                // Last transmission competed successfully.
   \   0000000E   ....               LDI     R30, LOW(TWI_statusReg)
   \   00000010   ....               LDI     R31, (TWI_statusReg) >> 8
   \   00000012   8100               LD      R16, Z
   \   00000014   FF00               SBRS    R16, 0
   \   00000016   C00F               RJMP    ??TWI_Get_Data_From_Transceiver_1
    119             {
    120                for(i = 0; i < msgSize; i += 1)           // Copy data from Transceiver buffer.
   \   00000018   E000               LDI     R16, 0
   \   0000001A   C00B               RJMP    ??TWI_Get_Data_From_Transceiver_2
    121                   msg[i] = TWI_buf[i];
   \                     ??TWI_Get_Data_From_Transceiver_3:
   \   0000001C   E010               LDI     R17, 0
   \   0000001E   01F8               MOVW    R31:R30, R17:R16
   \   00000020   ....               SUBI    R30, LOW((-(TWI_buf) & 0xFFFF))
   \   00000022   ....               SBCI    R31, (-(TWI_buf) & 0xFFFF) >> 8
   \   00000024   8120               LD      R18, Z
   \   00000026   E010               LDI     R17, 0
   \   00000028   01FC               MOVW    R31:R30, R25:R24
   \   0000002A   0FE0               ADD     R30, R16
   \   0000002C   1FF1               ADC     R31, R17
   \   0000002E   8320               ST      Z, R18
   \   00000030   9503               INC     R16
   \                     ??TWI_Get_Data_From_Transceiver_2:
   \   00000032   170A               CP      R16, R26
   \   00000034   F398               BRCS    ??TWI_Get_Data_From_Transceiver_3
    122             }
    123             return TWI_statusReg.lastTransOK;
   \                     ??TWI_Get_Data_From_Transceiver_1:
   \   00000036   ....               LDI     R30, LOW(TWI_statusReg)
   \   00000038   ....               LDI     R31, (TWI_statusReg) >> 8
   \   0000003A   8100               LD      R16, Z
   \   0000003C   7001               ANDI    R16, 0x01
   \   0000003E   E0E3               LDI     R30, 3
   \   00000040   ........           JMP     ?EPILOGUE_B3_L09
    124          }
    125          
    126          // ********** Interrupt Handlers ********** //
    127          /****************************************************************************
    128          This function is the Interrupt Service Routine (ISR), and called when the TWI interrupt is triggered;
    129          that is whenever a TWI event has occurred. This function should not be called directly from the main
    130          application.
    131          ****************************************************************************/
    132          
    133          //ISR(TWI_vect)
    134          
    135          #pragma   vector=TWI_vect // 

   \                                 In  segment CODE, align 2, keep-with-next
    136          __interrupt void twi_isr()
   \                     twi_isr:
    137          {
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   93FA               ST      -Y, R31
   \   00000006   93EA               ST      -Y, R30
   \   00000008   933A               ST      -Y, R19
   \   0000000A   932A               ST      -Y, R18
   \   0000000C   931A               ST      -Y, R17
   \   0000000E   930A               ST      -Y, R16
   \   00000010   B73F               IN      R19, 0x3F
    138          
    139             static uint8_t TWI_bufPtr;
    140             switch(TWSR)
   \   00000012   9100....           LDS     R16, _A_TWSR
   \   00000016   5008               SUBI    R16, 8
   \   00000018   F089               BREQ    ??twi_isr_0
   \   0000001A   5008               SUBI    R16, 8
   \   0000001C   F079               BREQ    ??twi_isr_0
   \   0000001E   5008               SUBI    R16, 8
   \   00000020   F081               BREQ    ??twi_isr_1
   \   00000022   5100               SUBI    R16, 16
   \   00000024   F071               BREQ    ??twi_isr_1
   \   00000026   5100               SUBI    R16, 16
   \   00000028   F409               BRNE    $+2+2
   \   0000002A   C05E               RJMP    ??twi_isr_2
   \   0000002C   5008               SUBI    R16, 8
   \   0000002E   F1C1               BREQ    ??twi_isr_3
   \   00000030   5100               SUBI    R16, 16
   \   00000032   F141               BREQ    ??twi_isr_4
   \   00000034   5008               SUBI    R16, 8
   \   00000036   F409               BRNE    $+2+2
   \   00000038   C045               RJMP    ??twi_isr_5
   \   0000003A   C05A               RJMP    ??twi_isr_6
    141             {
    142                case TWI_START:             // START has been transmitted
    143                case TWI_REP_START:         // Repeated START has been transmitted
    144                   TWI_bufPtr = 0;          // Set buffer pointer to the TWI Address location
   \                     ??twi_isr_0:
   \   0000003C   E000               LDI     R16, 0
   \   0000003E   9300....           STS     ??TWI_bufPtr, R16
    145                case TWI_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    146                case TWI_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
    147                   if(TWI_bufPtr < TWI_msgSize)
   \                     ??twi_isr_1:
   \   00000042   9100....           LDS     R16, ??TWI_bufPtr
   \   00000046   9110....           LDS     R17, TWI_msgSize
   \   0000004A   1701               CP      R16, R17
   \   0000004C   F490               BRCC    ??twi_isr_7
    148                   {
    149                      TWDR = TWI_buf[TWI_bufPtr++];
   \   0000004E   9100....           LDS     R16, ??TWI_bufPtr
   \   00000052   E010               LDI     R17, 0
   \   00000054   01F8               MOVW    R31:R30, R17:R16
   \   00000056   ....               SUBI    R30, LOW((-(TWI_buf) & 0xFFFF))
   \   00000058   ....               SBCI    R31, (-(TWI_buf) & 0xFFFF) >> 8
   \   0000005A   8100               LD      R16, Z
   \   0000005C   9300....           STS     _A_TWDR, R16
   \   00000060   9100....           LDS     R16, ??TWI_bufPtr
   \   00000064   9503               INC     R16
   \   00000066   9300....           STS     ??TWI_bufPtr, R16
    150                      TWCR = (1<<TWEN)|                          // TWI Interface enabled
    151                             (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
    152                             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|
    153                             (0<<TWWC);
   \   0000006A   E805               LDI     R16, 133
   \   0000006C   9300....           STS     _A_TWCR, R16
   \   00000070   C046               RJMP    ??twi_isr_8
    154                   }
    155                   else                     // Send STOP after last byte
    156                   {
    157                      TWI_statusReg.lastTransOK = TRUE;          // Set status bits to completed successfully.
   \                     ??twi_isr_7:
   \   00000072   ....               LDI     R30, LOW(TWI_statusReg)
   \   00000074   ....               LDI     R31, (TWI_statusReg) >> 8
   \   00000076   8100               LD      R16, Z
   \   00000078   6001               ORI     R16, 0x01
   \   0000007A   8300               ST      Z, R16
    158                      TWCR = (1<<TWEN)|                          // TWI Interface enabled
    159                             (0<<TWIE)|(1<<TWINT)|               // Disable TWI Interrupt and clear the flag
    160                             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|    // Initiate a STOP condition.
    161                             (0<<TWWC);
   \   0000007C   E904               LDI     R16, 148
   \   0000007E   9300....           STS     _A_TWCR, R16
    162                   }
    163                   break;
   \   00000082   C03D               RJMP    ??twi_isr_8
    164                case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
    165                   TWI_buf[TWI_bufPtr++] = TWDR;
   \                     ??twi_isr_4:
   \   00000084   9120....           LDS     R18, _A_TWDR
   \   00000088   9100....           LDS     R16, ??TWI_bufPtr
   \   0000008C   E010               LDI     R17, 0
   \   0000008E   01F8               MOVW    R31:R30, R17:R16
   \   00000090   ....               SUBI    R30, LOW((-(TWI_buf) & 0xFFFF))
   \   00000092   ....               SBCI    R31, (-(TWI_buf) & 0xFFFF) >> 8
   \   00000094   8320               ST      Z, R18
   \   00000096   9100....           LDS     R16, ??TWI_bufPtr
   \   0000009A   9503               INC     R16
   \   0000009C   9300....           STS     ??TWI_bufPtr, R16
    166                case TWI_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
    167                   if(TWI_bufPtr < (TWI_msgSize-1))              // Detect the last byte to NACK it.
   \                     ??twi_isr_3:
   \   000000A0   9100....           LDS     R16, ??TWI_bufPtr
   \   000000A4   E010               LDI     R17, 0
   \   000000A6   9180....           LDS     R24, TWI_msgSize
   \   000000AA   E090               LDI     R25, 0
   \   000000AC   9701               SBIW    R25:R24, 1
   \   000000AE   1708               CP      R16, R24
   \   000000B0   0719               CPC     R17, R25
   \   000000B2   F424               BRGE    ??twi_isr_9
    168                   {
    169                      TWCR = (1<<TWEN)|                          // TWI Interface enabled
    170                             (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to read next byte
    171                             (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Send ACK after reception
    172                             (0<<TWWC);
   \   000000B4   EC05               LDI     R16, 197
   \   000000B6   9300....           STS     _A_TWCR, R16
   \   000000BA   C021               RJMP    ??twi_isr_8
    173                   }
    174                   else                     // Send NACK after next reception
    175                   {
    176                      TWCR = (1<<TWEN)|                          // TWI Interface enabled
    177                         (1<<TWIE)|(1<<TWINT)|                   // Enable TWI Interrupt and clear the flag to read next byte
    178                         (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|        // Send NACK after reception
    179                         (0<<TWWC);
   \                     ??twi_isr_9:
   \   000000BC   E805               LDI     R16, 133
   \   000000BE   9300....           STS     _A_TWCR, R16
    180                   }
    181                   break;
   \   000000C2   C01D               RJMP    ??twi_isr_8
    182                case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
    183                   TWI_buf[TWI_bufPtr] = TWDR;
   \                     ??twi_isr_5:
   \   000000C4   9120....           LDS     R18, _A_TWDR
   \   000000C8   9100....           LDS     R16, ??TWI_bufPtr
   \   000000CC   E010               LDI     R17, 0
   \   000000CE   01F8               MOVW    R31:R30, R17:R16
   \   000000D0   ....               SUBI    R30, LOW((-(TWI_buf) & 0xFFFF))
   \   000000D2   ....               SBCI    R31, (-(TWI_buf) & 0xFFFF) >> 8
   \   000000D4   8320               ST      Z, R18
    184                   TWI_statusReg.lastTransOK = TRUE;             // Set status bits to completed successfully.
   \   000000D6   ....               LDI     R30, LOW(TWI_statusReg)
   \   000000D8   ....               LDI     R31, (TWI_statusReg) >> 8
   \   000000DA   8100               LD      R16, Z
   \   000000DC   6001               ORI     R16, 0x01
   \   000000DE   8300               ST      Z, R16
    185                   TWCR = (1<<TWEN)|                             // TWI Interface enabled
    186                          (0<<TWIE)|(1<<TWINT)|                  // Disable TWI Interrupt and clear the flag
    187                          (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|       // Initiate a STOP condition.
    188                          (0<<TWWC);
   \   000000E0   E904               LDI     R16, 148
   \   000000E2   9300....           STS     _A_TWCR, R16
    189                   break;
   \   000000E6   C00B               RJMP    ??twi_isr_8
    190                case TWI_ARB_LOST:          // Arbitration lost
    191                   TWCR = (1<<TWEN)|                             // TWI Interface enabled
    192                          (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interrupt and clear the flag
    193                          (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a (RE)START condition.
    194                          (0<<TWWC);
   \                     ??twi_isr_2:
   \   000000E8   EA05               LDI     R16, 165
   \   000000EA   9300....           STS     _A_TWCR, R16
    195                   break;
   \   000000EE   C007               RJMP    ??twi_isr_8
    196                case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    197                case TWI_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    198                case TWI_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received
    199                case TWI_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
    200          //      case TWI_NO_STATE           // No relevant state information available; TWINT = '0'
    201                default:
    202                   TWI_state = TWSR;                              // Store TWSR and automatically clears no Errors bit.
   \                     ??twi_isr_6:
   \   000000F0   9100....           LDS     R16, _A_TWSR
   \   000000F4   9300....           STS     TWI_state, R16
    203                                                                  // Reset TWI Interface
    204                   TWCR = (1<<TWEN)|                              // Enable TWI-interface and release TWI pins
    205                          (0<<TWIE)|(1<<TWINT)|                   // Disable Interrupt
    206                          (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|        // Initiate a STOP condition.
    207                          (0<<TWWC);
   \   000000F8   E904               LDI     R16, 148
   \   000000FA   9300....           STS     _A_TWCR, R16
    208             }
    209          }
   \                     ??twi_isr_8:
   \   000000FE   BF3F               OUT     0x3F, R19
   \   00000100   9109               LD      R16, Y+
   \   00000102   9119               LD      R17, Y+
   \   00000104   9129               LD      R18, Y+
   \   00000106   9139               LD      R19, Y+
   \   00000108   91E9               LD      R30, Y+
   \   0000010A   91F9               LD      R31, Y+
   \   0000010C   9189               LD      R24, Y+
   \   0000010E   9199               LD      R25, Y+
   \   00000110   9518               RETI
   \   00000112                      REQUIRE _A_TWDR
   \   00000112                      REQUIRE _A_TWCR
   \   00000112                      REQUIRE _A_TWSR

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \                     ??TWI_bufPtr:
   \   00000000                      DS8 1
    210          

   \                                 In  segment CODE, align 2, keep-with-next
    211          uint8_t TWI_Act_On_Failure_In_Last_Transmission (uint8_t TWIerrorMsg)
   \                     TWI_Act_On_Failure_In_Last_Transmission:
    212          {
   \   00000000   938A               ST      -Y, R24
   \   00000002   2F80               MOV     R24, R16
    213             // A failure has occurred, use TWIerrorMsg to determine the nature of the failure
    214             // and take appropriate actions.
    215             // See header file for a list of possible failures messages.
    216          
    217             // Here is a simple sample, where if received a NACK on the slave address,
    218             // then a retransmission will be initiated.
    219             if((TWIerrorMsg == TWI_MTX_ADR_NACK) | (TWIerrorMsg == TWI_MRX_ADR_NACK))
   \   00000004   3280               CPI     R24, 32
   \   00000006   F031               BREQ    ??TWI_Act_On_Failure_In_Last_Transmission_0
   \   00000008   E000               LDI     R16, 0
   \   0000000A   3488               CPI     R24, 72
   \   0000000C   F019               BREQ    ??TWI_Act_On_Failure_In_Last_Transmission_0
   \   0000000E   6000               ORI     R16, 0x00
   \   00000010   2300               TST     R16
   \   00000012   F009               BREQ    ??TWI_Act_On_Failure_In_Last_Transmission_1
    220                TWI_Start_Transceiver();
   \                     ??TWI_Act_On_Failure_In_Last_Transmission_0:
   \   00000014   ....               RCALL   TWI_Start_Transceiver
    221             return TWIerrorMsg;
   \                     ??TWI_Act_On_Failure_In_Last_Transmission_1:
   \   00000016   2F08               MOV     R16, R24
   \   00000018   9189               LD      R24, Y+
   \   0000001A   9508               RET
    222          }

   \                                 In  segment INTVEC, offset 0x60, root
   \                     `??twi_isr??INTVEC 96`:
   \   00000060   ........           JMP     twi_isr

   \                                 In  segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for TWI_state>`:
   \   00000000   F8                 DC8 248

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
       1      2  TWI_Act_On_Failure_In_Last_Transmission
                   1 2 -> TWI_Start_Transceiver
       3      2  TWI_Get_Data_From_Transceiver
                   3 2 -> TWI_Transceiver_Busy
       0      2  TWI_Get_State_Info
                   0 2 -> TWI_Transceiver_Busy
       0      2  TWI_Master_Initialise
       0      2  TWI_Start_Transceiver
                   0 2 -> TWI_Transceiver_Busy
       4      2  TWI_Start_Transceiver_With_Data
                   4 2 -> TWI_Transceiver_Busy
       0      2  TWI_Transceiver_Busy
       8      2  twi_isr


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for TWI_state>
       4  ??twi_isr??INTVEC 96
      28  TWI_Act_On_Failure_In_Last_Transmission
      68  TWI_Get_Data_From_Transceiver
      12  TWI_Get_State_Info
      26  TWI_Master_Initialise
      26  TWI_Start_Transceiver
      86  TWI_Start_Transceiver_With_Data
      10  TWI_Transceiver_Busy
      16  TWI_buf
       1  TWI_bufPtr
       1  TWI_msgSize
       1  TWI_state
       1  TWI_statusReg
       1  _A_TWBR
       1  _A_TWCR
       1  _A_TWDR
       1  _A_TWSR
     274  twi_isr
      12  -- Other

 
   4 bytes in segment ABSOLUTE
 530 bytes in segment CODE
  12 bytes in segment INITTAB
   4 bytes in segment INTVEC
   1 byte  in segment NEAR_I
   1 byte  in segment NEAR_ID
  19 bytes in segment NEAR_Z
 
 531 bytes of CODE memory (+ 16 bytes shared)
  20 bytes of DATA memory (+  4 bytes shared)

Errors: none
Warnings: none
