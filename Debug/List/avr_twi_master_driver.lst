###############################################################################
#
# IAR C/C++ Compiler V7.20.4.1567 for Microchip AVR       11/Jun/2021  12:51:09
# Copyright 1996-2019 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for Atmel AVR
#
#    Source file  =  
#        C:\Users\troub\CloudStation\Github\GitHub_DST\1. Remove Smoke
#        System\4.
#        MIDO\DST-MIDO-ALMDDS-JST_v1.4_3224\Source\drivers\atmel_driver\avr_twi_master_driver.c
#    Command line =  
#        -f C:\Users\troub\AppData\Local\Temp\EW20CC.tmp
#        ("C:\Users\troub\CloudStation\Github\GitHub_DST\1. Remove Smoke
#        System\4.
#        MIDO\DST-MIDO-ALMDDS-JST_v1.4_3224\Source\drivers\atmel_driver\avr_twi_master_driver.c"
#        --cpu=m168pa -ms -o "C:\Users\troub\CloudStation\Github\GitHub_DST\1.
#        Remove Smoke System\4. MIDO\DST-MIDO-ALMDDS-JST_v1.4_3224\Debug\Obj"
#        -lC "C:\Users\troub\CloudStation\Github\GitHub_DST\1. Remove Smoke
#        System\4. MIDO\DST-MIDO-ALMDDS-JST_v1.4_3224\Debug\List" -lA
#        "C:\Users\troub\CloudStation\Github\GitHub_DST\1. Remove Smoke
#        System\4. MIDO\DST-MIDO-ALMDDS-JST_v1.4_3224\Debug\List"
#        --initializers_in_flash --no_cse --no_inline --no_code_motion
#        --no_cross_call --no_clustering --no_tbaa --debug -e -I
#        "C:\Users\troub\CloudStation\Github\GitHub_DST\1. Remove Smoke
#        System\4.
#        MIDO\DST-MIDO-ALMDDS-JST_v1.4_3224\Source\drivers\min_driver\" -I
#        "C:\Users\troub\CloudStation\Github\GitHub_DST\1. Remove Smoke
#        System\4.
#        MIDO\DST-MIDO-ALMDDS-JST_v1.4_3224\Source\drivers\atmel_driver\" -I
#        "C:\Users\troub\CloudStation\Github\GitHub_DST\1. Remove Smoke
#        System\4. MIDO\DST-MIDO-ALMDDS-JST_v1.4_3224\Source\" -I
#        "C:\Users\troub\CloudStation\Github\GitHub_DST\1. Remove Smoke
#        System\4. MIDO\DST-MIDO-ALMDDS-JST_v1.4_3224\" --eeprom_size 512
#        --dlib --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.0\avr\LIB\DLIB\dlAVR-3s-ec_mul-sf-n.h" -Ol)
#    Locale       =  Korean_KOR.949
#    List file    =  
#        C:\Users\troub\CloudStation\Github\GitHub_DST\1. Remove Smoke
#        System\4.
#        MIDO\DST-MIDO-ALMDDS-JST_v1.4_3224\Debug\List\avr_twi_master_driver.lst
#    Object file  =  
#        C:\Users\troub\CloudStation\Github\GitHub_DST\1. Remove Smoke
#        System\4.
#        MIDO\DST-MIDO-ALMDDS-JST_v1.4_3224\Debug\Obj\avr_twi_master_driver.r90
#
###############################################################################

C:\Users\troub\CloudStation\Github\GitHub_DST\1. Remove Smoke System\4. MIDO\DST-MIDO-ALMDDS-JST_v1.4_3224\Source\drivers\atmel_driver\avr_twi_master_driver.c
      1          /*****************************************************************************
      2          * Atmel Corporation
      3          * File              : TWI_master.c
      4          * Revision          : 1.13
      5          * Date              : 24. mai 2004 11:31:20
      6          * Updated by        : ltwa
      7          * Support mail      : avr@atmel.com
      8          * Supported devices : All devices with a TWI module can be used.
      9          * AppNote           : AVR315 - TWI master Implementation
     10          * Description       : This is a sample driver for the TWI hardware modules.
     11          *                     It is interrupt driven. All functionality is controlled through
     12          *                     passing information to and from functions. 
     13          ****************************************************************************/
     14          //#include "TWI_master.h"
     15          //#include <stdint.h>
     16          //#include <avr/io.h>
     17          //#include <avr/interrupt.h>
     18          
     19          #include "include.h"

   \                                 In  segment ABSOLUTE, at 0xbc
   \   union <unnamed> volatile __io _A_TWCR
   \                     _A_TWCR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xbb
   \   union <unnamed> volatile __io _A_TWDR
   \                     _A_TWDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xb9
   \   union <unnamed> volatile __io _A_TWSR
   \                     _A_TWSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xb8
   \   union <unnamed> volatile __io _A_TWBR
   \                     _A_TWBR:
   \   00000000                      DS8 1
     20          

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     21          uint8_t TWI_buf[TWI_BUFFER_SIZE];     // Transceiver buffer
   \                     TWI_buf:
   \   00000000                      DS8 16

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     22          static uint8_t TWI_msgSize;                  // Number of bytes to be transmitted.
   \                     TWI_msgSize:
   \   00000000                      DS8 1

   \                                 In  segment NEAR_I, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_I>`
     23          static uint8_t TWI_state = TWI_NO_STATE;     // State byte. Default set to TWI_NO_STATE.
   \                     TWI_state:
   \   00000000                      DS8 1
   \   00000001                      REQUIRE `?<Initializer for TWI_state>`
     24          

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     25          union TWI_statusReg_f TWI_statusReg = {0};         // TWI_statusReg is defined in TWI_master.h
   \                     TWI_statusReg:
   \   00000000                      DS8 1
     26          
     27          /****************************************************************************
     28          Call this function to set up the TWI master to its initial standby state.
     29          Remember to enable interrupts from the main application after initializing the TWI.
     30          ****************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     31          void TWI_Master_Initialise(void)
   \                     TWI_Master_Initialise:
     32          {
     33             TWBR = TWI_TWBR;                                // Set bit rate register (Baudrate). Defined in header file.
   \   00000000   E200               LDI     R16, 32
   \   00000002   9300....           STS     _A_TWBR, R16
     34             TWSR = TWI_TWPS;                               // Set prescaler
   \   00000006   E000               LDI     R16, 0
   \   00000008   9300....           STS     _A_TWSR, R16
     35             TWDR = 0xFF;                                    // Default content = SDA released.
   \   0000000C   EF0F               LDI     R16, 255
   \   0000000E   9300....           STS     _A_TWDR, R16
     36             TWCR = (1<<TWEN)|                               // Enable TWI-interface and release TWI pins.
     37                    (0<<TWIE)|(0<<TWINT)|                    // Disable Interrupt.
     38                    (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|         // No Signal requests.
     39                    (0<<TWWC);
   \   00000012   E004               LDI     R16, 4
   \   00000014   9300....           STS     _A_TWCR, R16
     40          }
   \   00000018   9508               RET
   \   0000001A                      REQUIRE _A_TWBR
   \   0000001A                      REQUIRE _A_TWSR
   \   0000001A                      REQUIRE _A_TWDR
   \   0000001A                      REQUIRE _A_TWCR
     41          
     42          /****************************************************************************
     43          Call this function to test if the TWI_ISR is busy transmitting.
     44          ****************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     45          uint8_t TWI_Transceiver_Busy(void)
   \                     TWI_Transceiver_Busy:
     46          {
     47             return TWCR & (1<<TWIE);                     // IF TWI Interrupt is enabled then the Transceiver is busy
   \   00000000   9110....           LDS     R17, _A_TWCR
   \   00000004   2F01               MOV     R16, R17
   \   00000006   7001               ANDI    R16, 0x01
   \   00000008   9508               RET
   \   0000000A                      REQUIRE _A_TWCR
     48          }
     49          
     50          /****************************************************************************
     51          Call this function to fetch the state information of the previous operation. The function will hold execution (loop)
     52          until the TWI_ISR has completed with the previous operation. If there was an error, then the function
     53          will return the TWI State code.
     54          ****************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     55          uint8_t TWI_Get_State_Info(void)
   \                     TWI_Get_State_Info:
   \                     ??TWI_Get_State_Info_0:
     56          {
     57             while(TWI_Transceiver_Busy());               // Wait until TWI has completed the transmission.
   \   00000000   ....               RCALL   TWI_Transceiver_Busy
   \   00000002   2300               TST     R16
   \   00000004   F7E9               BRNE    ??TWI_Get_State_Info_0
     58             return TWI_state;                            // Return error state.
   \   00000006   9100....           LDS     R16, TWI_state
   \   0000000A   9508               RET
     59          }
     60          
     61          /****************************************************************************
     62          Call this function to send a prepared message. The first byte must contain the slave address and the
     63          read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
     64          from the slave. Also include how many bytes that should be sent/read including the address byte.
     65          The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
     66          then initialize the next operation and return.
     67          ****************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     68          void TWI_Start_Transceiver_With_Data(uint8_t *msg, uint8_t msgSize)
   \                     TWI_Start_Transceiver_With_Data:
     69          {
   \   00000000   01AD               MOVW    R21:R20, R27:R26
   \   00000002   01D8               MOVW    R27:R26, R17:R16
     70             uint8_t temp;
     71             while(TWI_Transceiver_Busy());                // Wait until TWI is ready for next transmission.
   \                     ??TWI_Start_Transceiver_With_Data_0:
   \   00000004   ....               RCALL   TWI_Transceiver_Busy
   \   00000006   2300               TST     R16
   \   00000008   F7E9               BRNE    ??TWI_Start_Transceiver_With_Data_0
     72          
     73             TWI_msgSize = msgSize;                        // Number of data to transmit.
   \   0000000A   9320....           STS     TWI_msgSize, R18
     74             TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
   \   0000000E   910C               LD      R16, X
   \   00000010   9300....           STS     TWI_buf, R16
     75             if(!(msg[0] & (TRUE<<TWI_READ_BIT)))          // If it is a write operation, then also copy data.
   \   00000014   01FD               MOVW    R31:R30, R27:R26
   \   00000016   8100               LD      R16, Z
   \   00000018   FD00               SBRC    R16, 0
   \   0000001A   C00F               RJMP    ??TWI_Start_Transceiver_With_Data_1
     76             {
     77                for(temp = 1; temp < msgSize; temp += 1)
   \   0000001C   E001               LDI     R16, 1
   \   0000001E   C00B               RJMP    ??TWI_Start_Transceiver_With_Data_2
     78                   TWI_buf[temp] = msg[temp];
   \                     ??TWI_Start_Transceiver_With_Data_3:
   \   00000020   E010               LDI     R17, 0
   \   00000022   01FD               MOVW    R31:R30, R27:R26
   \   00000024   0FE0               ADD     R30, R16
   \   00000026   1FF1               ADC     R31, R17
   \   00000028   8130               LD      R19, Z
   \   0000002A   E010               LDI     R17, 0
   \   0000002C   01F8               MOVW    R31:R30, R17:R16
   \   0000002E   ....               SUBI    R30, LOW((-(TWI_buf) & 0xFFFF))
   \   00000030   ....               SBCI    R31, (-(TWI_buf) & 0xFFFF) >> 8
   \   00000032   8330               ST      Z, R19
   \   00000034   9503               INC     R16
   \                     ??TWI_Start_Transceiver_With_Data_2:
   \   00000036   1702               CP      R16, R18
   \   00000038   F398               BRCS    ??TWI_Start_Transceiver_With_Data_3
     79             }
     80          
     81             TWI_statusReg.all = 0;
   \                     ??TWI_Start_Transceiver_With_Data_1:
   \   0000003A   E000               LDI     R16, 0
   \   0000003C   9300....           STS     TWI_statusReg, R16
     82             TWI_state = TWI_NO_STATE;
   \   00000040   EF08               LDI     R16, 248
   \   00000042   9300....           STS     TWI_state, R16
     83             TWCR = (1<<TWEN)|                             // TWI Interface enabled.
     84                    (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interrupt and clear the flag.
     85                    (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
     86                    (0<<TWWC);
   \   00000046   EA05               LDI     R16, 165
   \   00000048   9300....           STS     _A_TWCR, R16
     87          }
   \   0000004C   01DA               MOVW    R27:R26, R21:R20
   \   0000004E   9508               RET
   \   00000050                      REQUIRE _A_TWCR
     88          
     89          /****************************************************************************
     90          Call this function to resend the last message. The driver will reuse the data previously put in the transceiver buffers.
     91          The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
     92          then initialize the next operation and return.
     93          ****************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     94          void TWI_Start_Transceiver(void)
   \                     TWI_Start_Transceiver:
   \                     ??TWI_Start_Transceiver_0:
     95          {
     96             while(TWI_Transceiver_Busy());                // Wait until TWI is ready for next transmission.
   \   00000000   ....               RCALL   TWI_Transceiver_Busy
   \   00000002   2300               TST     R16
   \   00000004   F7E9               BRNE    ??TWI_Start_Transceiver_0
     97             TWI_statusReg.all = 0;
   \   00000006   E000               LDI     R16, 0
   \   00000008   9300....           STS     TWI_statusReg, R16
     98             TWI_state = TWI_NO_STATE;
   \   0000000C   EF08               LDI     R16, 248
   \   0000000E   9300....           STS     TWI_state, R16
     99             TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    100                    (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interrupt and clear the flag.
    101                    (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
    102                    (0<<TWWC);
   \   00000012   EA05               LDI     R16, 165
   \   00000014   9300....           STS     _A_TWCR, R16
    103          }
   \   00000018   9508               RET
   \   0000001A                      REQUIRE _A_TWCR
    104          
    105          /****************************************************************************
    106          Call this function to read out the requested data from the TWI transceiver buffer. I.e. first call
    107          TWI_Start_Transceiver to send a request for data to the slave. Then Run this function to collect the
    108          data when they have arrived. Include a pointer to where to place the data and the number of bytes
    109          requested (including the address field) in the function call. The function will hold execution (loop)
    110          until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
    111          If there was an error in the previous transmission the function will return the TWI error code.
    112          ****************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    113          uint8_t TWI_Get_Data_From_Transceiver(uint8_t *msg, uint8_t msgSize)
   \                     TWI_Get_Data_From_Transceiver:
    114          {
   \   00000000   01A8               MOVW    R21:R20, R17:R16
    115             uint8_t i;
    116             while(TWI_Transceiver_Busy());               // Wait until TWI is ready for next transmission.
   \                     ??TWI_Get_Data_From_Transceiver_0:
   \   00000002   ....               RCALL   TWI_Transceiver_Busy
   \   00000004   2300               TST     R16
   \   00000006   F7E9               BRNE    ??TWI_Get_Data_From_Transceiver_0
    117          
    118             if(TWI_statusReg.lastTransOK)                // Last transmission competed successfully.
   \   00000008   ....               LDI     R30, LOW(TWI_statusReg)
   \   0000000A   ....               LDI     R31, (TWI_statusReg) >> 8
   \   0000000C   8100               LD      R16, Z
   \   0000000E   FF00               SBRS    R16, 0
   \   00000010   C00F               RJMP    ??TWI_Get_Data_From_Transceiver_1
    119             {
    120                for(i = 0; i < msgSize; i += 1)           // Copy data from Transceiver buffer.
   \   00000012   E000               LDI     R16, 0
   \   00000014   C00B               RJMP    ??TWI_Get_Data_From_Transceiver_2
    121                   msg[i] = TWI_buf[i];
   \                     ??TWI_Get_Data_From_Transceiver_3:
   \   00000016   E010               LDI     R17, 0
   \   00000018   01F8               MOVW    R31:R30, R17:R16
   \   0000001A   ....               SUBI    R30, LOW((-(TWI_buf) & 0xFFFF))
   \   0000001C   ....               SBCI    R31, (-(TWI_buf) & 0xFFFF) >> 8
   \   0000001E   8130               LD      R19, Z
   \   00000020   E010               LDI     R17, 0
   \   00000022   01FA               MOVW    R31:R30, R21:R20
   \   00000024   0FE0               ADD     R30, R16
   \   00000026   1FF1               ADC     R31, R17
   \   00000028   8330               ST      Z, R19
   \   0000002A   9503               INC     R16
   \                     ??TWI_Get_Data_From_Transceiver_2:
   \   0000002C   1702               CP      R16, R18
   \   0000002E   F398               BRCS    ??TWI_Get_Data_From_Transceiver_3
    122             }
    123             return TWI_statusReg.lastTransOK;
   \                     ??TWI_Get_Data_From_Transceiver_1:
   \   00000030   ....               LDI     R30, LOW(TWI_statusReg)
   \   00000032   ....               LDI     R31, (TWI_statusReg) >> 8
   \   00000034   8100               LD      R16, Z
   \   00000036   7001               ANDI    R16, 0x01
   \   00000038   9508               RET
    124          }
    125          
    126          // ********** Interrupt Handlers ********** //
    127          /****************************************************************************
    128          This function is the Interrupt Service Routine (ISR), and called when the TWI interrupt is triggered;
    129          that is whenever a TWI event has occurred. This function should not be called directly from the main
    130          application.
    131          ****************************************************************************/
    132          
    133          //ISR(TWI_vect)
    134          
    135          #pragma   vector=TWI_vect // 

   \                                 In  segment CODE, align 2, keep-with-next
    136          __interrupt void twi_isr()
   \                     twi_isr:
    137          {
   \   00000000   93FA               ST      -Y, R31
   \   00000002   93EA               ST      -Y, R30
   \   00000004   933A               ST      -Y, R19
   \   00000006   932A               ST      -Y, R18
   \   00000008   931A               ST      -Y, R17
   \   0000000A   930A               ST      -Y, R16
   \   0000000C   B73F               IN      R19, 0x3F
    138          
    139             static uint8_t TWI_bufPtr;
    140             switch(TWSR)
   \   0000000E   9100....           LDS     R16, _A_TWSR
   \   00000012   5008               SUBI    R16, 8
   \   00000014   F089               BREQ    ??twi_isr_0
   \   00000016   5008               SUBI    R16, 8
   \   00000018   F079               BREQ    ??twi_isr_0
   \   0000001A   5008               SUBI    R16, 8
   \   0000001C   F081               BREQ    ??twi_isr_1
   \   0000001E   5100               SUBI    R16, 16
   \   00000020   F071               BREQ    ??twi_isr_1
   \   00000022   5100               SUBI    R16, 16
   \   00000024   F409               BRNE    $+2+2
   \   00000026   C05E               RJMP    ??twi_isr_2
   \   00000028   5008               SUBI    R16, 8
   \   0000002A   F1C1               BREQ    ??twi_isr_3
   \   0000002C   5100               SUBI    R16, 16
   \   0000002E   F141               BREQ    ??twi_isr_4
   \   00000030   5008               SUBI    R16, 8
   \   00000032   F409               BRNE    $+2+2
   \   00000034   C045               RJMP    ??twi_isr_5
   \   00000036   C05A               RJMP    ??twi_isr_6
    141             {
    142                case TWI_START:             // START has been transmitted
    143                case TWI_REP_START:         // Repeated START has been transmitted
    144                   TWI_bufPtr = 0;          // Set buffer pointer to the TWI Address location
   \                     ??twi_isr_0:
   \   00000038   E000               LDI     R16, 0
   \   0000003A   9300....           STS     ??TWI_bufPtr, R16
    145                case TWI_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    146                case TWI_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
    147                   if(TWI_bufPtr < TWI_msgSize)
   \                     ??twi_isr_1:
   \   0000003E   9100....           LDS     R16, ??TWI_bufPtr
   \   00000042   9110....           LDS     R17, TWI_msgSize
   \   00000046   1701               CP      R16, R17
   \   00000048   F490               BRCC    ??twi_isr_7
    148                   {
    149                      TWDR = TWI_buf[TWI_bufPtr++];
   \   0000004A   9100....           LDS     R16, ??TWI_bufPtr
   \   0000004E   E010               LDI     R17, 0
   \   00000050   01F8               MOVW    R31:R30, R17:R16
   \   00000052   ....               SUBI    R30, LOW((-(TWI_buf) & 0xFFFF))
   \   00000054   ....               SBCI    R31, (-(TWI_buf) & 0xFFFF) >> 8
   \   00000056   8100               LD      R16, Z
   \   00000058   9300....           STS     _A_TWDR, R16
   \   0000005C   9100....           LDS     R16, ??TWI_bufPtr
   \   00000060   9503               INC     R16
   \   00000062   9300....           STS     ??TWI_bufPtr, R16
    150                      TWCR = (1<<TWEN)|                          // TWI Interface enabled
    151                             (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
    152                             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|
    153                             (0<<TWWC);
   \   00000066   E805               LDI     R16, 133
   \   00000068   9300....           STS     _A_TWCR, R16
   \   0000006C   C046               RJMP    ??twi_isr_8
    154                   }
    155                   else                     // Send STOP after last byte
    156                   {
    157                      TWI_statusReg.lastTransOK = TRUE;          // Set status bits to completed successfully.
   \                     ??twi_isr_7:
   \   0000006E   ....               LDI     R30, LOW(TWI_statusReg)
   \   00000070   ....               LDI     R31, (TWI_statusReg) >> 8
   \   00000072   8100               LD      R16, Z
   \   00000074   6001               ORI     R16, 0x01
   \   00000076   8300               ST      Z, R16
    158                      TWCR = (1<<TWEN)|                          // TWI Interface enabled
    159                             (0<<TWIE)|(1<<TWINT)|               // Disable TWI Interrupt and clear the flag
    160                             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|    // Initiate a STOP condition.
    161                             (0<<TWWC);
   \   00000078   E904               LDI     R16, 148
   \   0000007A   9300....           STS     _A_TWCR, R16
    162                   }
    163                   break;
   \   0000007E   C03D               RJMP    ??twi_isr_8
    164                case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
    165                   TWI_buf[TWI_bufPtr++] = TWDR;
   \                     ??twi_isr_4:
   \   00000080   9120....           LDS     R18, _A_TWDR
   \   00000084   9100....           LDS     R16, ??TWI_bufPtr
   \   00000088   E010               LDI     R17, 0
   \   0000008A   01F8               MOVW    R31:R30, R17:R16
   \   0000008C   ....               SUBI    R30, LOW((-(TWI_buf) & 0xFFFF))
   \   0000008E   ....               SBCI    R31, (-(TWI_buf) & 0xFFFF) >> 8
   \   00000090   8320               ST      Z, R18
   \   00000092   9100....           LDS     R16, ??TWI_bufPtr
   \   00000096   9503               INC     R16
   \   00000098   9300....           STS     ??TWI_bufPtr, R16
    166                case TWI_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
    167                   if(TWI_bufPtr < (TWI_msgSize-1))              // Detect the last byte to NACK it.
   \                     ??twi_isr_3:
   \   0000009C   9100....           LDS     R16, ??TWI_bufPtr
   \   000000A0   E010               LDI     R17, 0
   \   000000A2   91E0....           LDS     R30, TWI_msgSize
   \   000000A6   E0F0               LDI     R31, 0
   \   000000A8   9731               SBIW    R31:R30, 1
   \   000000AA   170E               CP      R16, R30
   \   000000AC   071F               CPC     R17, R31
   \   000000AE   F424               BRGE    ??twi_isr_9
    168                   {
    169                      TWCR = (1<<TWEN)|                          // TWI Interface enabled
    170                             (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to read next byte
    171                             (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Send ACK after reception
    172                             (0<<TWWC);
   \   000000B0   EC05               LDI     R16, 197
   \   000000B2   9300....           STS     _A_TWCR, R16
   \   000000B6   C021               RJMP    ??twi_isr_8
    173                   }
    174                   else                     // Send NACK after next reception
    175                   {
    176                      TWCR = (1<<TWEN)|                          // TWI Interface enabled
    177                         (1<<TWIE)|(1<<TWINT)|                   // Enable TWI Interrupt and clear the flag to read next byte
    178                         (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|        // Send NACK after reception
    179                         (0<<TWWC);
   \                     ??twi_isr_9:
   \   000000B8   E805               LDI     R16, 133
   \   000000BA   9300....           STS     _A_TWCR, R16
    180                   }
    181                   break;
   \   000000BE   C01D               RJMP    ??twi_isr_8
    182                case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
    183                   TWI_buf[TWI_bufPtr] = TWDR;
   \                     ??twi_isr_5:
   \   000000C0   9120....           LDS     R18, _A_TWDR
   \   000000C4   9100....           LDS     R16, ??TWI_bufPtr
   \   000000C8   E010               LDI     R17, 0
   \   000000CA   01F8               MOVW    R31:R30, R17:R16
   \   000000CC   ....               SUBI    R30, LOW((-(TWI_buf) & 0xFFFF))
   \   000000CE   ....               SBCI    R31, (-(TWI_buf) & 0xFFFF) >> 8
   \   000000D0   8320               ST      Z, R18
    184                   TWI_statusReg.lastTransOK = TRUE;             // Set status bits to completed successfully.
   \   000000D2   ....               LDI     R30, LOW(TWI_statusReg)
   \   000000D4   ....               LDI     R31, (TWI_statusReg) >> 8
   \   000000D6   8100               LD      R16, Z
   \   000000D8   6001               ORI     R16, 0x01
   \   000000DA   8300               ST      Z, R16
    185                   TWCR = (1<<TWEN)|                             // TWI Interface enabled
    186                          (0<<TWIE)|(1<<TWINT)|                  // Disable TWI Interrupt and clear the flag
    187                          (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|       // Initiate a STOP condition.
    188                          (0<<TWWC);
   \   000000DC   E904               LDI     R16, 148
   \   000000DE   9300....           STS     _A_TWCR, R16
    189                   break;
   \   000000E2   C00B               RJMP    ??twi_isr_8
    190                case TWI_ARB_LOST:          // Arbitration lost
    191                   TWCR = (1<<TWEN)|                             // TWI Interface enabled
    192                          (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interrupt and clear the flag
    193                          (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a (RE)START condition.
    194                          (0<<TWWC);
   \                     ??twi_isr_2:
   \   000000E4   EA05               LDI     R16, 165
   \   000000E6   9300....           STS     _A_TWCR, R16
    195                   break;
   \   000000EA   C007               RJMP    ??twi_isr_8
    196                case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    197                case TWI_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    198                case TWI_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received
    199                case TWI_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
    200          //      case TWI_NO_STATE           // No relevant state information available; TWINT = '0'
    201                default:
    202                   TWI_state = TWSR;                              // Store TWSR and automatically clears no Errors bit.
   \                     ??twi_isr_6:
   \   000000EC   9100....           LDS     R16, _A_TWSR
   \   000000F0   9300....           STS     TWI_state, R16
    203                                                                  // Reset TWI Interface
    204                   TWCR = (1<<TWEN)|                              // Enable TWI-interface and release TWI pins
    205                          (0<<TWIE)|(1<<TWINT)|                   // Disable Interrupt
    206                          (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|        // Initiate a STOP condition.
    207                          (0<<TWWC);
   \   000000F4   E904               LDI     R16, 148
   \   000000F6   9300....           STS     _A_TWCR, R16
    208             }
    209          }
   \                     ??twi_isr_8:
   \   000000FA   BF3F               OUT     0x3F, R19
   \   000000FC   9109               LD      R16, Y+
   \   000000FE   9119               LD      R17, Y+
   \   00000100   9129               LD      R18, Y+
   \   00000102   9139               LD      R19, Y+
   \   00000104   91E9               LD      R30, Y+
   \   00000106   91F9               LD      R31, Y+
   \   00000108   9518               RETI
   \   0000010A                      REQUIRE _A_TWDR
   \   0000010A                      REQUIRE _A_TWCR
   \   0000010A                      REQUIRE _A_TWSR

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \                     ??TWI_bufPtr:
   \   00000000                      DS8 1
    210          

   \                                 In  segment CODE, align 2, keep-with-next
    211          uint8_t TWI_Act_On_Failure_In_Last_Transmission (uint8_t TWIerrorMsg)
   \                     TWI_Act_On_Failure_In_Last_Transmission:
    212          {
   \   00000000   2F20               MOV     R18, R16
    213             // A failure has occurred, use TWIerrorMsg to determine the nature of the failure
    214             // and take appropriate actions.
    215             // See header file for a list of possible failures messages.
    216          
    217             // Here is a simple sample, where if received a NACK on the slave address,
    218             // then a retransmission will be initiated.
    219             if((TWIerrorMsg == TWI_MTX_ADR_NACK) | (TWIerrorMsg == TWI_MRX_ADR_NACK))
   \   00000002   3220               CPI     R18, 32
   \   00000004   F011               BREQ    ??TWI_Act_On_Failure_In_Last_Transmission_0
   \   00000006   3428               CPI     R18, 72
   \   00000008   F409               BRNE    ??TWI_Act_On_Failure_In_Last_Transmission_1
    220                TWI_Start_Transceiver();
   \                     ??TWI_Act_On_Failure_In_Last_Transmission_0:
   \   0000000A   ....               RCALL   TWI_Start_Transceiver
    221             return TWIerrorMsg;
   \                     ??TWI_Act_On_Failure_In_Last_Transmission_1:
   \   0000000C   2F02               MOV     R16, R18
   \   0000000E   9508               RET
    222          }

   \                                 In  segment INTVEC, offset 0x60, root
   \                     `??twi_isr::??INTVEC 96`:
   \   00000060   ........           JMP     twi_isr

   \                                 In  segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for TWI_state>`:
   \   00000000   F8                 DC8 248

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      0      2   TWI_Act_On_Failure_In_Last_Transmission
        0      2   -> TWI_Start_Transceiver
      0      2   TWI_Get_Data_From_Transceiver
        0      2   -> TWI_Transceiver_Busy
      0      2   TWI_Get_State_Info
        0      2   -> TWI_Transceiver_Busy
      0      2   TWI_Master_Initialise
      0      2   TWI_Start_Transceiver
        0      2   -> TWI_Transceiver_Busy
      0      2   TWI_Start_Transceiver_With_Data
        0      2   -> TWI_Transceiver_Busy
      0      2   TWI_Transceiver_Busy
      6      2   twi_isr


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for TWI_state>
      16  TWI_Act_On_Failure_In_Last_Transmission
      58  TWI_Get_Data_From_Transceiver
      12  TWI_Get_State_Info
      26  TWI_Master_Initialise
      26  TWI_Start_Transceiver
      80  TWI_Start_Transceiver_With_Data
      10  TWI_Transceiver_Busy
      16  TWI_buf
       1  TWI_bufPtr
       1  TWI_msgSize
       1  TWI_state
       1  TWI_statusReg
       1  _A_TWBR
       1  _A_TWCR
       1  _A_TWDR
       1  _A_TWSR
     266  twi_isr
       4  twi_isr::??INTVEC 96
      12  -- Other

 
   4 bytes in segment ABSOLUTE
 494 bytes in segment CODE
  12 bytes in segment INITTAB
   4 bytes in segment INTVEC
   1 byte  in segment NEAR_I
   1 byte  in segment NEAR_ID
  19 bytes in segment NEAR_Z
 
 495 bytes of CODE memory (+ 16 bytes shared)
  20 bytes of DATA memory (+  4 bytes shared)

Errors: none
Warnings: none
